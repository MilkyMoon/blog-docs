### Redis的持久化机制

<br desc/>

Redis提供了两种将内存数据持久化到硬盘的两种方式，一种是RDB文件，另一种是AOF文件，默认的执行是RDB文件持久化方式。

<br desc/>

#### RDB(默认)
RDB方式是通过存储**快照**完成的，当**符合一定条件**时将会自动将内存中的数据进行快照并存储到名字为`dump.rdb`的二进制文件（经过压缩的）中。

##### 手动保存

可以通过`SAVE`或者`BGSAVE`命令手动让Redis进行数据集的保存操作。

SAVE

SAVE命令将当前Redis实例的所有数据快照以RDB文件的形式保存到硬盘中。SAVE命令会阻塞Redis进程，一般都会使用BGSAVE命令来异步保存，主要用在后台子进程出现问题时，保存数据的最后手段。

```shell
redis> SAVE
OK
```

BGSAVE

在后台异步的将数据保存到磁盘上。命令执行后会立即返回`OK`，后台会`fork`出一个子进程来负责保存数据到磁盘，原来的Redis进程将继续处理客户端请求。

```shell
redis> BGSAVE
Background saving started
```

> 当服务端正在执行BGSAVE命令期间，客户端发起了SAVE命令，则服务端将拒绝客户端的SAVE命令请求。主要是为了防止同时对一个文件进行操作产生的竞争行为。



##### RDB文件的同步

redis.conf文件中默认配置如下：

```
save 900 1
save 300 10
save 60 10000
```

分别表示900秒内至少执行1次数据修改，300秒以内至少执行10次数据修改，60秒内至少执行10000次数据修改。只要满足其中一条，数据库就会执行RDB文件的同步操作。



##### RDB快照运作流程

1. Redis调用`fork()`创建一个子进程。
2. 子进程将内存中的数据集写入到一个临时RDB文件中。
3. 当子进程完成了对临时文件的写入时，Redis将用新的RDB文件替换原来的RDB文件，并删除旧的RDB文件。



##### RDB的优点

- RDB在恢复大数据集的时候速度比AOF要快。
- RDB非常适合灾难恢复。
- 减少了磁盘IO的次数。

##### RDB的缺点

- 如果服务器出现故障停机，那么会丢失最近一次保存之后修改的数据。
- Redis每次保存RDB的时候都要`fork()`出一个子进程，当数据集非常庞大的时候，`fork()`可能会非常耗时，造成服务器在这段时间内停止处理客户端请求。



#### AOF

默认情况下Redis没有开启AOF。修改配置文件`redis.conf`中的`appendonly yes ` 来开启AOF，开启AOF之后每执行一条`更改Redis数据集`的命令，该命令就会被写入到磁盘中的AOF文件中。

#####  手动保存



##### AOF文件的同步

会将更改数据集的命令放入`系统内存缓冲区`，会按照`appendfsync`配置写入AOF文件。

redis.conf文件中默认配置如下：

```
#appendfsync always		#每次执行写入操作都会进行同步
appendfsync everysec  #每秒执行一次
#appendfsync no				#不主动进行同步操作，由操作系统去执行
```



##### AOF的rewrite机制

Redis主进程会fork一个子进程对当前内存中的数据进行扫描，转换成一系列的Redis操作指令，并序列化到一个新的AOF文件中，然后序列化期间新的操作指令追加到新的AOF文件中，替换旧AOF文件。

redis.conf文件中默认配置如下：

```
auto-rewrite-percentage 100  #表示当前aof文件大小超过上一次aof文件大小的百分之多少的时候进行重写。如果没有重写过，则以启动时aof文件大小为准
auto-rewrite-min-size 64mb   #主大小达到64mb的时候启动rewrite机制
```



##### AOF的优点

- 如果服务器发生故障停机，AOF会将信息丢失降低到最少。
- 当AOF文件过大时，Redis会自动的在后台重写AOF，新的AOF文件将包含恢复当前数据集所需的最小命令集合。
- AOF文件非常容易被人读懂，我们可以手动修改AOF文件来重新恢复数据。



##### AOF的缺点

- AOF文件体积要比RDB文件要大。
- AOF通常情况下要比RDB慢，关闭`fsync`可以让AOF与RDB一样快。
- 磁盘IO比较频繁，对系统性能有影响





